<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Midnight Maze - Random Death Messages</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        canvas { width: 100vw; height: 100vh; display: block; cursor: none; }
        
        #ui { position: absolute; top: 20px; left: 20px; color: #3f3; text-shadow: 1px 1px 2px #000; z-index: 10; pointer-events: none; font-weight: bold; }
        .bar-container { margin: 10px 0; }
        .bar { width: 150px; height: 10px; border: 1px solid #fff; background: #222; }
        .fill { height: 100%; width: 100%; transition: width 0.2s; }
        #l-fill { background: #ffcc00; box-shadow: 0 0 10px #ffcc00; }
        #n-fill { background: #00ff00; box-shadow: 0 0 10px #00ff00; }
        
        #msg { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
               color: #f00; font-size: 3rem; font-weight: bold; display: none; text-shadow: 0 0 20px #f00; 
               text-align: center; width: 100%; text-transform: uppercase; }
        
        #debug { position: absolute; bottom: 10px; left: 10px; color: #fff; font-size: 12px; pointer-events: none; opacity: 0.7; }
    </style>
</head>
<body>

<div id="ui">
    <div class="bar-container">
        LANTERNA (F) [ <span id="l-stat" style="color:#ffcc00">OFF</span> ]
        <div class="bar"><div id="l-fill" class="fill" style="width: 100%;"></div></div>
    </div>
    <div class="bar-container">
        VISÃO NOTURNA (N) [ <span id="n-stat" style="color:#00ff00">OFF</span> ]
        <div class="bar"><div id="n-fill" class="fill" style="width:100%"></div></div>
    </div>
</div>

<div id="msg">VOCÊ MORREU</div>
<div id="debug">Carregando texturas...</div>
<canvas id="glCanvas"></canvas>

<script id="vs" type="x-shader/x-vertex">
    attribute vec3 aPosition;
    attribute vec3 aNormal;
    attribute vec2 aUv;
    
    uniform mat4 uMvp;   
    uniform mat4 uModel; 
    
    varying vec3 vNormal; 
    varying vec3 vFragPos; 
    varying vec2 vUv; 
    
    void main() {
        vec4 worldPos = uModel * vec4(aPosition, 1.0);
        vFragPos = worldPos.xyz;
        vNormal = mat3(uModel) * aNormal; 
        vUv = aUv;
        gl_Position = uMvp * vec4(aPosition, 1.0);
    }
</script>

<script id="fs" type="x-shader/x-fragment">
    precision mediump float;
    
    varying vec3 vNormal;
    varying vec3 vFragPos;
    varying vec2 vUv;
    
    uniform vec3 uCamPos;
    uniform vec3 uMoonDir;
    uniform vec3 uMoonColor;
    
    uniform bool uFlashOn;
    uniform float uFlashBatt;
    uniform vec3 uCamDir;
    
    uniform bool uNvOn;
    uniform float uNvBatt;
    
    uniform sampler2D uTex;
    uniform vec3 uTint; 
    uniform float uShininess; 
    uniform float uEmissive; 
    uniform float uTime;

    float rand(vec2 co) { return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }

    void main() {
        vec3 norm = normalize(vNormal);
        vec3 viewDir = normalize(uCamPos - vFragPos);
        
        vec4 texData = texture2D(uTex, vUv);
        vec3 texColor = texData.rgb;
        float alpha = texData.a;

        if(uEmissive > 0.5) {
            if(alpha < 0.1) discard; 
            gl_FragColor = vec4(texColor, alpha); 
            return;
        }

        vec3 albedo = texColor * uTint;

        // 1. Lua
        vec3 ambient = 0.1 * uMoonColor * albedo; 
        
        vec3 lightDir = normalize(uMoonDir);
        float diff = max(dot(norm, lightDir), 0.0);
        vec3 diffuse = diff * uMoonColor * albedo * 0.5;
        
        vec3 halfwayDir = normalize(lightDir + viewDir);
        float spec = pow(max(dot(norm, halfwayDir), 0.0), uShininess);
        vec3 specular = vec3(0.3) * spec * 0.5;
        
        vec3 finalColor = ambient + diffuse + specular;

        // 2. Lanterna
        if(uFlashOn && uFlashBatt > 0.0) {
            vec3 flashDir = normalize(vFragPos - uCamPos);
            float theta = dot(flashDir, normalize(uCamDir));
            
            if(theta > 0.91) { 
                float intensity = smoothstep(0.91, 0.98, theta);
                float dist = distance(vFragPos, uCamPos);
                float atten = 1.0 / (1.0 + 0.09*dist + 0.032*dist*dist);
                
                float lightPower = 1.0; 
                if(uFlashBatt < 0.1) {
                    float flicker = rand(vec2(floor(uTime * 15.0), 1.0));
                    if(flicker < 0.4) lightPower = 0.0;
                }

                float diffF = max(dot(norm, -flashDir), 0.0);
                vec3 halfF = normalize(-flashDir + viewDir);
                float specF = pow(max(dot(norm, halfF), 0.0), uShininess);
                
                vec3 flashColor = vec3(1.0, 0.95, 0.85);
                finalColor += (diffF * albedo + specF * vec3(0.5)) * flashColor * intensity * atten * 5.0 * lightPower;
            }
        }

        // 3. Visão Noturna
        if(uNvOn && uNvBatt > 0.0) {
            float lum = dot(finalColor, vec3(0.3, 0.59, 0.11));
            vec3 nvColor = vec3(0.0, 1.0, 0.1) * lum * 40.0 * uNvBatt;
            float noise = rand(vFragPos.xy + uTime);
            finalColor = (nvColor + vec3(noise * 0.15));
        }

        gl_FragColor = vec4(finalColor, 1.0);
    }
</script>

<script>
// --- MATH LIB ---
const M4 = {
    identity: () => new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]),
    perspective: (fov, asp, n, f) => {
        let t = Math.tan(fov/2), r = 1/(n-f);
        return new Float32Array([1/(t*asp),0,0,0, 0,1/t,0,0, 0,0,(n+f)*r,-1, 0,0,2*n*f*r,0]);
    },
    multiply: (a, b) => {
        let out = new Float32Array(16);
        for(let i=0; i<4; i++) for(let j=0; j<4; j++) {
            let s = 0; for(let k=0; k<4; k++) s += a[i+k*4] * b[k+j*4];
            out[i+j*4] = s;
        }
        return out;
    },
    translate: (m, x, y, z) => {
        let t = M4.identity(); t[12]=x; t[13]=y; t[14]=z;
        return M4.multiply(m, t);
    },
    scale: (m, x, y, z) => {
        let s = M4.identity(); s[0]=x; s[5]=y; s[10]=z;
        return M4.multiply(m, s);
    },
    rotateY: (m, a) => {
        let r = M4.identity(), c = Math.cos(a), s = Math.sin(a);
        r[0]=c; r[2]=-s; r[8]=s; r[10]=c; return M4.multiply(m, r);
    },
    lookAt: (eye, target, up) => {
        let z = normalize(sub(eye, target));
        let x = normalize(cross(up, z));
        let y = cross(z, x);
        return new Float32Array([ x[0], y[0], z[0], 0, x[1], y[1], z[1], 0, x[2], y[2], z[2], 0, -dot(x, eye), -dot(y, eye), -dot(z, eye), 1 ]);
    }
};
const sub = (a,b) => [a[0]-b[0], a[1]-b[1], a[2]-b[2]];
const cross = (a,b) => [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]];
const dot = (a,b) => a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
const normalize = v => { let l = Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]); return l>0 ? [v[0]/l, v[1]/l, v[2]/l] : [0,0,0]; };

const DEATH_MSGS = [
    "TEM QUE SE FUDÊ E ACABOU",
    "FAZ O L",
    "~~VOCÊ ESFAQUEOU O BOLZO SEM QUERER~~",
    "VOCÊ PERDEU POR CULPA DO PT",
    "GANHEI PORRA !!!",
    "NÃO VÃO PEGAR MEU CELULAR",
    "SE VIRAR JACARÉ, PROBLEMA SEU",
    "~~VOCÊ FOI SOLUÇADO~~",
    "~~VOCÊ PEGOU A MAMADEIRA DE PIROK DO BOLZO~~"
];

const MAP_SIZE = 20;
const MAP = [
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,
    1,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,
    1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,1,
    1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,0,1,0,1,
    1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,
    1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,1,
    1,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,
    1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,0,1,
    1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,
    1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0,1,
    1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,1,
    1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,0,1,0,1,
    1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,
    1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,1,
    1,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,
    1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,0,1,
    1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,
    1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
];

let gl, program, canvas;
let texWall, texGround, texMoon, texMonster;

let camPos = [2.5, 1.7, 2.5];
let yaw = 0, pitch = 0;
let keys = {}, flOn = false, nvOn = false;
let flBatt = 1.0, nvBatt = 1.0;
let time = 0.0;
let cubeVBO, planeVBO;
let enemyPos = [10.5, 1.0, 10.5]; 
let enemySpeed = 0.035;
let gameOver = false;

function loadTexture(url) {
    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); 
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([128,128,128,255]));
    
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => {
        console.log("Carregado: " + url);
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    };
    img.onerror = () => {
        console.error("ERRO IMG: " + url);
        document.getElementById('debug').innerText = "ERRO: " + url;
    };
    img.src = url;
    return tex;
}

function init() {
    canvas = document.getElementById("glCanvas");
    gl = canvas.getContext("webgl");
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    canvas.onclick = () => canvas.requestPointerLock();

    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    window.addEventListener('keydown', e => {
        keys[e.key.toLowerCase()] = true;
        if(e.key === 'f') flOn = !flOn;
        if(e.key === 'n') nvOn = !nvOn;
    });
    window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
    
    document.onmousemove = e => {
        if(document.pointerLockElement === canvas && !gameOver) {
            yaw += e.movementX * 0.002;
            pitch -= e.movementY * 0.002;
            pitch = Math.max(-1.5, Math.min(1.5, pitch));
        }
    }

    const s = (t, src) => { let sh = gl.createShader(t); gl.shaderSource(sh, src); gl.compileShader(sh); return sh; };
    program = gl.createProgram();
    gl.attachShader(program, s(gl.VERTEX_SHADER, document.getElementById('vs').text));
    gl.attachShader(program, s(gl.FRAGMENT_SHADER, document.getElementById('fs').text));
    gl.linkProgram(program); gl.useProgram(program);

    texWall = loadTexture('parede.jpg');
    texGround = loadTexture('chao.jpg');
    texMoon = loadTexture('lua.png'); 
    texMonster = loadTexture('monstro.jpg');

    let cube = [];
    const addFace = (u,v,w, u2,v2,w2, u3,v3,w3, u4,v4,w4, nx,ny,nz) => {
        cube.push(u,v,w, nx,ny,nz, 0,0, u2,v2,w2, nx,ny,nz, 1,0, u3,v3,w3, nx,ny,nz, 0,1);
        cube.push(u3,v3,w3, nx,ny,nz, 0,1, u2,v2,w2, nx,ny,nz, 1,0, u4,v4,w4, nx,ny,nz, 1,1);
    };
    addFace(-0.5,0.5,-0.5, 0.5,0.5,-0.5, -0.5,0.5,0.5, 0.5,0.5,0.5, 0,1,0); 
    addFace(-0.5,-0.5,0.5, 0.5,-0.5,0.5, -0.5,0.5,0.5, 0.5,0.5,0.5, 0,0,1); 
    addFace(0.5,-0.5,-0.5, -0.5,-0.5,-0.5, 0.5,0.5,-0.5, -0.5,0.5,-0.5, 0,0,-1); 
    addFace(0.5,-0.5,0.5, 0.5,-0.5,-0.5, 0.5,0.5,0.5, 0.5,0.5,-0.5, 1,0,0); 
    addFace(-0.5,-0.5,-0.5, -0.5,-0.5,0.5, -0.5,0.5,-0.5, -0.5,0.5,0.5, -1,0,0); 
    addFace(-0.5,-0.5,0.5, 0.5,-0.5,0.5, -0.5,-0.5,-0.5, 0.5,-0.5,-0.5, 0,-1,0);

    cubeVBO = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, cubeVBO);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cube), gl.STATIC_DRAW);

    let plane = [
        -0.5,0,-0.5, 0,1,0, 0,0,  0.5,0,-0.5, 0,1,0, 50,0,
        -0.5,0,0.5, 0,1,0, 0,50,  0.5,0,0.5, 0,1,0, 50,50
    ];
    planeVBO = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, planeVBO);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(plane), gl.STATIC_DRAW);

    gl.enable(gl.DEPTH_TEST);
    gl.clearColor(0.02, 0.02, 0.05, 1.0); 
    render();
}

function checkWall(x, z) {
    let gx = Math.floor(x / 2.0);
    let gz = Math.floor(z / 2.0);
    if (gx < 0 || gx >= MAP_SIZE || gz < 0 || gz >= MAP_SIZE) return true;
    return MAP[gz * MAP_SIZE + gx] === 1;
}

function render() {
    if (gameOver) return;
    requestAnimationFrame(render);
    time += 0.005;

    let speed = 0.08;
    let dx = 0, dz = 0;
    if(keys['w']) { dx += Math.sin(yaw)*speed; dz -= Math.cos(yaw)*speed; }
    if(keys['s']) { dx -= Math.sin(yaw)*speed; dz += Math.cos(yaw)*speed; }
    if(keys['a']) { dx -= Math.cos(yaw)*speed; dz -= Math.sin(yaw)*speed; }
    if(keys['d']) { dx += Math.cos(yaw)*speed; dz += Math.sin(yaw)*speed; }
    
    if(!checkWall(camPos[0]+dx, camPos[2])) camPos[0]+=dx;
    if(!checkWall(camPos[0], camPos[2]+dz)) camPos[2]+=dz;

    if(flOn && flBatt > 0) flBatt -= 0.0005; else if (flBatt <= 0) flOn = false;
    if(nvOn && nvBatt > 0) nvBatt -= 0.0008; else if (nvBatt <= 0) nvOn = false;
    
    document.getElementById('l-fill').style.width = (flBatt*100)+"%";
    document.getElementById('n-fill').style.width = (nvBatt*100)+"%";
    document.getElementById('l-stat').innerText = flOn ? "ON" : "OFF";
    document.getElementById('n-stat').innerText = nvOn ? "ON" : "OFF";

    let vecX = camPos[0] - enemyPos[0];
    let vecZ = camPos[2] - enemyPos[2];
    let dist = Math.sqrt(vecX*vecX + vecZ*vecZ);
    
    if (dist < 0.8) {
        gameOver = true;
        
        // SORTEIA FRASE ALEATÓRIA
        let randomMsg = DEATH_MSGS[Math.floor(Math.random() * DEATH_MSGS.length)];
        let msgEl = document.getElementById('msg');
        msgEl.innerText = randomMsg;
        msgEl.style.display = 'block';
        
        document.exitPointerLock();
    }

    let camDirX = Math.sin(yaw);
    let camDirZ = -Math.cos(yaw);
    let toEnemyX = -vecX/dist; 
    let toEnemyZ = -vecZ/dist;
    let dot = camDirX * toEnemyX + camDirZ * toEnemyZ;
    let isSeen = (flOn && flBatt > 0 && dot > 0.7 && dist < 20.0); 
    
    if (!isSeen) {
        let mx = (vecX/dist)*enemySpeed;
        let mz = (vecZ/dist)*enemySpeed;
        if(!checkWall(enemyPos[0]+mx, enemyPos[2])) enemyPos[0] += mx;
        if(!checkWall(enemyPos[0], enemyPos[2]+mz)) enemyPos[2] += mz;
    }

    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    let target = [camPos[0] + Math.sin(yaw), camPos[1] + Math.sin(pitch), camPos[2] - Math.cos(yaw)];
    let view = M4.lookAt(camPos, target, [0,1,0]);
    let proj = M4.perspective(Math.PI/4, canvas.width/canvas.height, 0.1, 100);
    let vp = M4.multiply(proj, view);

    gl.useProgram(program);
    
    let moonX = Math.sin(time*0.2) * 40.0 + 20.0;
    let moonZ = Math.cos(time*0.2) * 40.0 + 20.0;
    
    gl.uniform3f(gl.getUniformLocation(program, "uCamPos"), camPos[0], camPos[1], camPos[2]);
    gl.uniform3f(gl.getUniformLocation(program, "uMoonDir"), moonX, 25.0, moonZ); 
    gl.uniform3f(gl.getUniformLocation(program, "uMoonColor"), 0.2, 0.3, 0.6); 
    gl.uniform3f(gl.getUniformLocation(program, "uCamDir"), Math.sin(yaw)*Math.cos(pitch), Math.sin(pitch), -Math.cos(yaw)*Math.cos(pitch));
    
    gl.uniform1i(gl.getUniformLocation(program, "uFlashOn"), flOn);
    gl.uniform1f(gl.getUniformLocation(program, "uFlashBatt"), flBatt);
    gl.uniform1i(gl.getUniformLocation(program, "uNvOn"), nvOn);
    gl.uniform1f(gl.getUniformLocation(program, "uNvBatt"), nvBatt);
    gl.uniform1f(gl.getUniformLocation(program, "uTime"), time);
    gl.uniform1i(gl.getUniformLocation(program, "uTex"), 0);

    let pL = gl.getAttribLocation(program, "aPosition");
    let nL = gl.getAttribLocation(program, "aNormal");
    let uL = gl.getAttribLocation(program, "aUv");
    gl.enableVertexAttribArray(pL); gl.enableVertexAttribArray(nL); gl.enableVertexAttribArray(uL);

    let uM = gl.getUniformLocation(program, "uModel");
    let uMVP = gl.getUniformLocation(program, "uMvp");
    let uTint = gl.getUniformLocation(program, "uTint");
    let uShin = gl.getUniformLocation(program, "uShininess");
    let uEmiss = gl.getUniformLocation(program, "uEmissive"); 

    // 1. LABIRINTO
    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVBO);
    gl.vertexAttribPointer(pL, 3, gl.FLOAT, false, 32, 0);
    gl.vertexAttribPointer(nL, 3, gl.FLOAT, false, 32, 12);
    gl.vertexAttribPointer(uL, 2, gl.FLOAT, false, 32, 24);
    
    gl.bindTexture(gl.TEXTURE_2D, texWall); 
    gl.uniform1f(uShin, 4.0);
    gl.uniform1f(uEmiss, 0.0);
    gl.uniform3f(uTint, 1.0, 1.0, 1.0);
    
    for(let z=0; z<MAP_SIZE; z++) {
        for(let x=0; x<MAP_SIZE; x++) {
            if(MAP[z*MAP_SIZE+x] === 1) {
                let model = M4.translate(M4.identity(), x*2+1, 1.5, z*2+1);
                model = M4.scale(model, 2, 3, 2);
                gl.uniformMatrix4fv(uM, false, model);
                gl.uniformMatrix4fv(uMVP, false, M4.multiply(vp, model));
                gl.drawArrays(gl.TRIANGLES, 0, 36);
            }
        }
    }

    // 2. INIMIGO
    gl.bindTexture(gl.TEXTURE_2D, texMonster); 
    gl.uniform3f(uTint, 1.0, 1.0, 1.0); 
    
    let eModel = M4.translate(M4.identity(), enemyPos[0], enemyPos[1], enemyPos[2]);
    eModel = M4.scale(eModel, 0.8, 1.8, 0.8);
    gl.uniformMatrix4fv(uM, false, eModel);
    gl.uniformMatrix4fv(uMVP, false, M4.multiply(vp, eModel));
    gl.drawArrays(gl.TRIANGLES, 0, 36);

    // 3. CHÃO
    gl.bindBuffer(gl.ARRAY_BUFFER, planeVBO);
    gl.vertexAttribPointer(pL, 3, gl.FLOAT, false, 32, 0);
    gl.vertexAttribPointer(nL, 3, gl.FLOAT, false, 32, 12);
    gl.vertexAttribPointer(uL, 2, gl.FLOAT, false, 32, 24);
    
    gl.bindTexture(gl.TEXTURE_2D, texGround);
    gl.uniform1f(uShin, 64.0); 
    gl.uniform3f(uTint, 1.0, 1.0, 1.0);
    
    let floorModel = M4.translate(M4.identity(), 20, 0, 20); 
    floorModel = M4.scale(floorModel, 100, 1, 100);
    gl.uniformMatrix4fv(uM, false, floorModel);
    gl.uniformMatrix4fv(uMVP, false, M4.multiply(vp, floorModel));
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    // 4. LUA
    gl.bindTexture(gl.TEXTURE_2D, texMoon);
    gl.uniform1f(uEmiss, 1.0); 
    
    let moonModel = M4.translate(M4.identity(), moonX, 25.0, moonZ);
    moonModel = M4.rotateY(moonModel, time * 0.1); 
    moonModel = M4.scale(moonModel, 8, 1, 8); 
    
    gl.uniformMatrix4fv(uM, false, moonModel);
    gl.uniformMatrix4fv(uMVP, false, M4.multiply(vp, moonModel));
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}
window.onload = init;
</script>
</body>
</html>